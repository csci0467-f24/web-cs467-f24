---
title: "CS 467 - Tutorial 10"
date: "2023-05-02"
due: "2023-05-11T14:15"
name: "Tutorial 10"
published: false
---




#### Goals
- Implement a genetic algorithm




## Prerequisites


1. Accept the assignment on our [Github Classroom](https://classroom.github.com/a/CzAu_Tu6). 
1. Clone the repository GitHub classroom creates to your local computer (in your shell, type `git clone` and the name of the repository)

## Objective

In this tutorial you are going to breed some drawing tools. These drawing tools are represented by an array of circles. Each circle has a radius (`radius`) and a number of revolutions per "cycle" (`revs`). The simplest drawing tool is a single circle. We imagine a pen attached to an arm the length of the radius. We cycle through a full rotation, and the pen will draw a circle. When we add a second circle, we attach it to the end of the arm instead of the pen (which will now be attached to the new circle). As the first circle iterates through its angles, the second circle is also iterating, potentially at a different rate. The more circles we have, the more complex the figure that is drawn.

![circle drawing tool](./tutorial10/circles.png)

If you didn't follow all of that, don't worry -- I wrote that part of the code for you. The only important piece is that we can describe these as an array of object with properties `radius` and `revs`. This is our genetic material. The array is the **genotype** and the drawing we make using it is the **phenotype** (how the genotype is expressed). 

Your task will be to try to breed these drawing tools to match a reference image (which will also be generated by one of these).

As a reminder of the process, we will:

- start by generating a population of random candidates
- score each candidate with some fitness function
- select pairs of candidates for cross-breeding based on their fitness scores
- mutate the children based on some mutation rate
- form a new population of the mutated children
- go back to step 2 and repeat



#### Starter code


I've provided you with some starter code to save us some time. You should go take a look at it. If you run it, you will see nine randomly generated shapes. The shape in the upper left is the target we are trying to approximate. The other eight are the eight best attempts to approximate it from the current population, in order. _At the moment, the population only has eight elements, so you are seeing them all._


Let's take a tour of the code. You will want to tinker with some of the constants, but for the most part the functions can be left alone, though it would be helpful to know what they are doing.

**Variables**

At the top there are a collection of constants. 

- `STEP` - you can probably leave this alone (though you are welcome to play with it). It controls the granularity of the sweep around the circles
- `POPULATION_SIZE` - this one is obvious. I set it to eight for now, but you will want to crank this up to 100-200 (or more) when you start the actual breeding.
- `TOURNAMENT_SIZE` - the size used for tournament selection
- `MUTATION_RATE` - the probability that we will mutate a gene
- `MUTATION_DEV` - the standard deviation that our mutation will undergo
- `LINE_MATCH` - (fitness function) bonus for places where both the target and the attempt have a line
- `COLOR_MATCH` - (fitness function) bonus for where the fill color matches
- `MISS_PENALTY` - (fitness function) penalty for having white where the target is colored
- `FALSE_HIT_PENALTY` - (fitness function) penalty for painting something that should be white

Other variables:

- `paused` - sets if the breed is happening or not -- can be set with the 'p' key
- `population` - an array for holding our attempts
- `target` - this is a graphics context holding an image of the target
- `targetGenotype` - the genotype that generated the target
- `scratchCanvas` - a graphics context for rendering attempts

The fitness function needs to look at rendered versions of our drawings, so the drawing function is set up to draw into a context. I discovered early on that if I created a new context for every attempt, the script would run out of memory and all sorts of weird things started happening. So we have one that gets reused. 



**`setup()`**

This is pretty straightforward. The only new thing is the call to `pixelDensity`. With retinal screens we can get multiple subpixels per pixel, which increases the amount of work we need to do in the fitness function. We don't really need the subpixel resolution, so we are turning it off. This also calls `initialize` to set up the target and initial population. 

**`draw()`**

This draws the target and the top eight attempts. It calls `nextGeneration()` to build the next generation.

**`initialize()`**

This creates the target and renders it to a graphics context. It also creates a random population. Notice that it generates a random genotype and then creates a new object literal containing the genotype and the fitness score. 


**`randomGenotype()`**

This creates our random genotypes. The most important thing to take away from this is the structure of the genes. As I said above, they have two properties: `radius` and `revs`.


**`drawPhenotype(genotype, ctx)`**

This function does the actual drawing of the shapes. The `genotype` provides the instructions and the `ctx` is the drawing surface. _Note that this takes the raw `genotype` - NOT the full attempt object with the score included._

**`pickCanddiate()`**

This function selects a candidate from the population for breeding. Currently it just returns a random member of the current population. You will change this later.

**`calculateScore(genotype)`**

This is responsible for calculating the fitness function. It renders the candidate genotype and then compares it pixel by pixel to the `target`. This is an important piece, but I decided to give it to you since there is a lot going on in there. Once everything is working, you are welcome to substitute oin your own fitness tests. 


**`keyTypes()`**

The key handler. There are two options:

- 'p' (pause) - pause or unpause the run. The process is compute heavy, so this can be handy when you are working and don't want to just leave it churning away
- 'c' (change) - This just reinitializes the system. It is roughly the same effect as reloading the page. 


## Implementation

Okay, now that you are somewhat acquainted with the code, it is time for you to dig in and finish it off.

### `nextGeneration()` (step one)

You will start with `nextGeneration()`, which is the most complex piece. We are going to build in in stages.


Our main objective in this function is to build a new population, so start by making an array called `newPopulation`. 

Next create a while loop that runs while the length of the new population is less than `POPULATION_SIZE`. Inside, call `pickCandidate` to randomly select an item from `population` and push it into `newPopulation`. 

After the loop, set `population` equal to `newPopulation`, then sort the population by score (you will find an example in `initialize`). 

If you run this, you should see some changes to the displayed images as we randomly lose then from the population. Eventually you will probably end up with a monoculture. You also won't have made any progress towards matching the target. 

### `mutate`

Our next step will be to add some mutation. The first argument to `mutate` will be a genome (again, NOT the full scored attempt -- just the genome). recall that the genome is an array of the gene objects. What we want to return is a _new_ genome that has some of the original genes and some mutated ones. 

The easiest way to do this is the use the `map` function (the one [built into Arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), not the p5js one). 

The `map` function takes in a function as an argument. That function is applied to each element of the array and then `map` returns a new array of all of the results. 

The function I would like you to write will take in a single gene. It should then generate a random number and if that number is less than the `rate`, then it will generate a mutated gene, otherwise it will return the original gene. 

To mutate the gene, I want you to return a new object with properties `radius` and `revs`. To generate the values of these, use `randomGaussian()`, centered on the original value with a deviation of `MUTATION_DEV`. You should then take the `floor` of the result so we end up with integer values (this is important for `revs` so we know when we complete the shape). 

Return the modified genome.


### `nextGeneration()` (step two)

Now we will return to `nextGeneration` and mutate the element we picked from the list. 

Pass the element's genome to `mutate` with the `MUTATION_RATE`. The result will be another raw genome. Pass it to `calculateScore` to get the score for this element.

Create a new object literal with properties `genome` and `score` and push that into `newPopulation` in addition to the original one. 

The population should now exhibit some change, and we may get some elements that are closer to the target (though it will mostly be coincidence). 


### `crossover`

The next function to address is the `crossover` function. This function takes in two genotypes and "breeds" them to produce a new pair. 

The mechanics of this is relatively simple. We break the first array and break it at a random location. Then we break the second array at a different random location. We then make two "children". The first one has the first half of the first genome and the second half of the second. The other has the first half of the second genome and the second half of the first. 

I recommend using [`slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) and [`concat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat).

Put the two children in an array and return the array. 

### `nextGeneration()` (step three)

Return to `nextGeneration`. 

Now, instead of pulling a single element from `population` at random, choose two. Take their genomes and use `crossover` to produce the two children. 

Unpack the children from the array they are returned in and then pass each of them to `mutate`. Then score them, bundle them, and add them to `nextGeneration`. So you should now be adding _four_ items to `newPopulation` with every iteration of the while loop -- the two children and the original two parents. 

You should now see some more variation in the population. Now would be a good time to increase the population size. Set it to something like 100. 


### `pickCandidate()`

There is a major component still missing. We calculated the fitness scores for everything, but other than the fact that we are only displaying the best ones, we aren't using the scores to control the breeding process.

Rather than choosing the elements that should send their genes forward at random, we are going to come up with a system that uses the score to favor the more successful ones. 

We will be using the **tournament** selection process. The process is relatively straightforward. We pick `TOURNAMENT_SIZE` elements from `population` at random and then return the best of this subset. 

Rather actually creating a subset, you can just write a loop that runs `TOURNAMENT_SIZE` times. Pick a candidate at random from population. If it has a better score then the one you already have, keep it. Return the one you still have at the end. 

You should now have something that evolves our little drawings and makes progress towards the target over time. 


## Play

This process illustrates the mechanics of writing a genetic algorithm, but to really appreciate what is going on you should play around with it a little bit -- particularly the fitness function.

### Fitness function

I have given you four "knobs" to play with to control the fitness function. Try changing the weights on the rewards and the penalties. It is a system of tradeoffs. I find that the collection of values I gave you are reasonably good at getting close to the shape and some of the internal structure. 

For many shapes, you will see the dense flower shape pop up as a candidate pretty often. This is probably due to the high award on matching the lines. The dense flower shape is a reasonable way to create a lot of lines to maximize the potential for overlap. 

If you turn down the line award, then it will tend towards very sparse shapes that just approximate the outside shape. This is easier than matching the generating lines. 

If you increase the penalty for drawing where there is white on the `target`, you will find that the elements fade away to nothing as the cheapest way to maximize the score. 

Play around with the settings and see what observations you make. You are also welcome to make your own fitness function to try to optimize other things. 

### Other variables

There are other variables for you to play with as well. You can adjust the `MUTATION_RATE` and `MUTATION_DEV`, which will have some impact on the genetic diversity. With our current set up, the population stabilizes relatively rapidly, though not always with a great result. Allowing more mutation will affect that. 

The `TOURNAMENT_SIZE` also has an impact on diversity. With a tournament size of 1, we have pure random selection. If the tournament size is equal to the size of the population, then we will just always pick the candidate with the highest score. 

Adjusting the `POPULATION_SIZE` also has an impact. The larger the population, the most chance you have for interesting explorations. The cost there is speed. 

Another thing you can try is only adding one of the parents (or none). Without the parents you wil see far more wild swings in different directions. The downside of this is that you can lose progress, but on the other hand, the parents can hold us in a local maximum. 



## Thoughts

It is a strange exercise to try to generate a shape when you already know how to generate it. It is not, generally speaking, even very good at it. For me, I like watching the process. These shapes can be interpolated from one to another, so it would be interesting to use this process to flow from one shape to another. 

It is worth thinking about why it doesn't converge on a better solution. I have occasionally gotten a perfect match, but more often than not it is at best an approximation, provided it doesn't collapse into simple circles. 

Some of this is because of the fitness function. It rewards pixel level matchings, but it doesn't see line continuity. Being pixel oriented also means that it will miss shapes that are almost exactly right but twisted slightly or slightly smaller. The blue tint was added to help address that a little bit. It helps to define the shape for the fitness function and keeps the optimizations either going for scribble everywhere to get points for black where there is black, or draw nothing to minimize the drawing on white penalty. 

The other factor is that the genome is not the most stable. Fairly small changes in the genome can have large changes in the phenom, which is not great for making small adjustments. Crossovers in particular can easily lose many of the good properties of the parents. Given all that, I think it is fascinating how quickly it can at least approximate the shape. 




## Finishing up

Commit your changes to git and push them back up to GitHub. I will find them there.

